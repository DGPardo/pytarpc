use futures::stream::StreamExt;
use rpc_model::model::{CustomDataType, RpcAPI};
use std::future::{Future, ready};

use tarpc::{
    context,
    serde_transport::tcp,
    server::{self, Channel, incoming::Incoming},
    tokio_serde::formats::Bincode,
};

#[derive(Clone)]
pub struct AppState;

impl RpcAPI for AppState {
    async fn hello(self, _context: context::Context, name: String) -> String {
        format!("hello {name}")
    }

    async fn sum_numbers(self, _context: context::Context, a: i32, b: i32) -> i32 {
        a + b
    }

    async fn echo(self, _context: context::Context, foo: CustomDataType) -> CustomDataType {
        foo
    }
}

async fn spawn(fut: impl Future<Output = ()> + Send + 'static) {
    tokio::spawn(fut);
}

#[tokio::main]
async fn main() -> anyhow::Result<()> {
    let mut listener = tcp::listen("0.0.0.0:5000", Bincode::default).await?;
    let addr = listener.local_addr();

    println!("Listening on: {:?}", addr);

    listener.config_mut().max_frame_length(usize::MAX);
    listener
        // Ignore accept errors.
        .filter_map(|r| {
            println!(
                "Received connection from: {:?}",
                r.as_ref().map(|r| r.peer_addr())
            );
            ready(r.ok())
        })
        .map(server::BaseChannel::with_defaults)
        // Limit channels to 1 per IP.
        .max_channels_per_key(1, |t| t.transport().peer_addr().unwrap().ip())
        // serve is generated by the service attribute. It takes as input any type implementing
        // the generated World trait.
        .map(|channel| {
            let server = AppState {};
            channel.execute(server.serve()).for_each(spawn)
        })
        // Max 10 channels.
        .buffer_unordered(10)
        .for_each(|_| async {})
        .await;

    Ok(())
}
